# Gitea 与 JupyterHub TLJH 集成：构建免登录、自动拉取的临时沙箱环境施工文档

## 1. 报告目标与架构总览

本技术实施指南（“施工文档”）旨在详细阐述一套完整的技术架构，用于将标准的 The Littlest JupyterHub (TLJH) 实例转变为一个为社会科学数据分析案例设计的、自动化的、临时的（ephemeral）沙箱服务。

该架构的核心目标是为学生提供一种“点击即运行”的无缝体验，其功能需求严格定义如下：

1. **免登录访问 (Login-Free Access):** 学生点击分享链接后，无需输入任何凭证，直接进入 Jupyter 环境。
2. **自动内容拉取 (Automatic Git Pull):** 环境启动时，自动从本地 Gitea 服务器拉取该链接对应的案例资源（一个 Gitea 仓库）。
3. **资源配置 (Resource Configuration):** 每个沙箱环境的 CPU 和内存资源必须受到预先配置的限制。
4. **空闲清理 (Idle Culling):** 长期处于非活动状态的沙箱环境将被自动关闭和清除。
5. **数据临时性 (Ephemeral Data):** 系统不负责保留学生的任何文件。所有用户数据和临时账户在会话结束后都将被自动、彻底地清理。

为了满足上述所有要求，本方案设计了一个基于四种核心组件精密协作的架构：

1. **`TmpAuthenticator`:** 用于处理“免登录”需求。它会自动为每个访问者创建临时的逻辑用户账户 ^1^。
2. **`SystemdSpawner` (配合 `dynamic_users`)** : 这是实现资源配置和数据清理的核心。它利用 `systemd` 的功能，为每个逻辑用户创建隔离的、临时的 *系统级用户* 沙箱。这些沙箱的资源（CPU/内存）受 `cgroups` 限制 ^3^，并且其所有数据（存储在 `/var/lib/{USERNAME}`）在服务停止后会被自动销毁 ^5^。
3. **`nbgitpuller`** : 用于处理“自动内容拉取”需求。它是一个 Jupyter 插件，能根据 URL 参数，在用户环境启动时自动从 Gitea 克隆或更新代码仓库 ^6^。
4. **`Idle Culler` 服务** : 用于处理“空闲清理”需求。它会监控并关闭超时的服务器 ^7^，并配置为在服务器关闭后，从 JupyterHub 数据库中删除对应的临时用户条目 ^7^。

此架构的关键在于 `TmpAuthenticator` 和 `SystemdSpawner` ( `dynamic_users=True` 模式) 的协同工作。`TmpAuthenticator` 解决了 *认证* 问题（创建逻辑用户），而 `SystemdSpawner` 解决了 *执行* 和 *隔离* 问题（创建临时的、受限的物理系统用户）^3^。这种组合是构建一个真正临时的、安全的、“用后即焚”沙箱环境的基石。

## 2. 阶段一：基础配置与 nbgitpuller 安装

此阶段的目标是确保 `nbgitpuller` 插件在 TLJH 的 *用户环境* 中正确安装并激活。

### 2.1 步骤 1：验证 nbgitpuller 安装状态

根据 TLJH 的标准配置，`nbgitpuller` 通常已作为基础环境的一部分被默认安装 ^8^。因此，首要步骤是验证其是否存在，以避免不必要的重装或版本冲突。

以 `admin` 管理员用户身份登录 JupyterHub，打开一个终端 (Terminal)，执行以下命令：

**Bash**

```
/opt/tljh/user/bin/pip show nbgitpuller
```

如果命令返回了 `nbgitpuller` 的包信息（版本、路径等），则说明已安装，可跳至步骤 3。

### 2.2 步骤 2：(条件性) 安装 nbgitpuller

如果步骤 1 未找到 `nbgitpuller`，则需要手动安装。

 **关键点** ：必须区分 TLJH 的两个核心环境 ^2^。`nbgitpuller` 是一个用户侧的插件（它在用户的 Notebook 服务器中运行），因此必须安装到 `/opt/tljh/user` 环境中，而不是 `/opt/tljh/hub` 环境 ^9^。

使用 `sudo -E` 命令（`-E` 参数用于保留环境变量，确保 `pip` 指向正确的路径）来执行安装 ^10^：

**Bash**

```
sudo -E /opt/tljh/user/bin/pip install nbgitpuller
```

### 2.3 步骤 3：确保 Server 扩展被激活

`nbgitpuller` 依赖一个 Jupyter Server 扩展来拦截和处理形如 `/git-pull` 的 URL 请求 ^6^。为确保（特别是旧版本）它被正确激活，执行以下命令 ^9^：

**Bash**

```
/opt/tljh/user/bin/jupyter serverextension enable nbgitpuller
```

### 2.4 步骤 4：重载 Hub 服务

为确保所有服务都识别到新配置，重载 JupyterHub：

**Bash**

```
sudo tljh-config reload hub
```

## 3. 阶段二：构建临时沙箱环境架构

此阶段的目标是实现“免登录”访问，并确保用户数据是完全临时的。

### 3.1 A 部分：实施免登录 (TmpAuthenticator)

 **架构洞察** ：认证器 (Authenticator) 是 JupyterHub *Hub* 服务的核心组件，因此 `TmpAuthenticator` 必须安装在 *Hub 环境* (`/opt/tljh/hub/bin/pip`) 中。将其安装到用户环境 (User environment) 是一个常见错误，会导致 Hub 启动失败并报告 `ImportError` ^2^。

#### 3.1.1 步骤 1：在 Hub 环境中安装 TmpAuthenticator

尽管 `TmpAuthenticator` 在 TLJH 的默认组件列表中 ^1^，但实践（和错误日志）表明，经常需要从 PyPI 显式安装它 ^2^。

通过 SSH 登录到服务器，执行：

**Bash**

```
sudo /opt/tljh/hub/bin/pip install jupyterhub-tmpauthenticator
```

#### 3.1.2 步骤 2：配置 TLJH 使用 TmpAuthenticator

TLJH 使用 `tljh-config` 工具来设置高级配置项 ^12^。我们需要将 `auth.type` 设置为 `TmpAuthenticator` 的完整 Python 类路径 ^2^。

**Bash**

```
sudo tljh-config set auth.type tmpauthenticator.TmpAuthenticator
```

#### 3.1.3 步骤 3：重载配置

更改认证器是重大变更，需要重载服务 ^2^：

**Bash**

```
sudo tljh-config reload
```

 **验证** ：此时，在浏览器的“无痕模式”或“隐私窗口”中打开您的 JupyterHub URL。您应该会看到您被自动登录（用户名为 `tmp-...`），并直接跳转到服务器启动页面，完全跳过了登录界面。

### 3.2 B 部分：启用动态隔离的用户沙箱

 **架构洞察** ：`tljh-config set` 命令主要用于设置简单的键值对（如字符串、数字）^13^。对于复杂的 Python 配置（如设置布尔值 `c.SystemdSpawner.dynamic_users = True`），它无法胜任。

TLJH 为此提供了“逃生舱口” (escape hatch)：`/opt/tljh/config/jupyterhub_config.d/` 目录 ^14^。任何放置在此目录中且以 `.py` 结尾的文件，都会在 `tljh-config` 配置加载 *之后* 按字母顺序作为 Python 配置文件加载。这是进行高级 Spawner 配置（如 `pre_spawn_hook` ^17^ 或 `SystemdSpawner` ^17^）的正确方法。

#### 3.2.1 步骤 1：创建自定义配置文件

通过 SSH 登录服务器：

**Bash**

```
sudo nano /opt/tljh/config/jupyterhub_config.d/99-ephemeral-users.py
```

*(使用 `99-` 前缀可确保它在其他配置之后加载)*

#### 3.2.2 步骤 2：启用动态用户

将以下内容粘贴到文件中。此配置指示 `SystemdSpawner` 使用 `systemd` 的 `DynamicUser=yes` 功能 ^3^。

 **后果** ：

1. 系统会为 `tmp-...` 用户动态分配一个临时的 UID/GID，而不是创建永久的系统用户 ^4^。
2. 该用户的主目录将被创建在 `/var/lib/{USERNAME}` ^5^。
3. 最重要的是：当该用户的 `systemd` 服务停止时，这个主目录及其所有内容将被系统自动、递归地删除，完美实现了“数据临时性”要求。

**Python**

```
# /opt/tljh/config/jupyterhub_config.d/99-ephemeral-users.py

"""
启用 SystemdSpawner 的动态用户功能。
这将为 TmpAuthenticator 创建的临时用户分配一个临时的、
非特权的系统用户身份 (UID/GID)，其主目录位于 /var/lib/{USERNAME}。
当服务停止时，此用户及其主目录将被 systemd 自动清除。
[3, 4, 5]
"""
c.SystemdSpawner.dynamic_users = True
```

#### 3.2.3 步骤 3：重载配置

因为这修改了 Spawner 的核心行为，所以需要重载：

**Bash**

```
sudo tljh-config reload
```

## 4. 阶段三：配置沙箱资源限制 (CPU 与内存)

此阶段的目标是满足“对每个沙箱环境的资源进行配置”的需求。

 **架构洞察** ：虽然标准的 JupyterHub `c.Spawner.mem_limit` ^19^ 并非在所有 Spawner 上都有效 ^20^，但 TLJH 默认使用的 `SystemdSpawner` ^21^ 可以利用 `systemd` 的 `cgroups` 功能来严格限制资源 ^3^。

TLJH 极大地简化了这一过程，它提供了 `limits.memory` 和 `limits.cpu` 这两个 `tljh-config` 快捷方式，它们会自动转换并应用到底层的 `SystemdSpawner` 配置中 ^13^。

### 4.1 步骤 1：设置内存限制

设置一个合理的内存上限（例如 4GB），以防止单个用户的分析任务（例如加载大型数据集）耗尽服务器总内存 ^13^。

**Bash**

```
# 为每个用户沙箱设置 4GB 内存硬上限
sudo tljh-config set limits.memory 4G
```

### 4.2 步骤 2：设置 CPU 限制

设置 CPU 核心数限制（例如 2 个核心）^13^。

**Bash**

```
# 为每个用户沙箱设置 2 个 CPU 核心的配额
sudo tljh-config set limits.cpu 2
```

### 4.3 步骤 3：重载配置

应用新的资源限制需要重载服务：

**Bash**

```
sudo tljh-config reload
```

 **验证** ：当有用户服务器运行时，您可以通过 SSH 登录并运行 `systemd-cgtop` ^3^。您将看到一个以 `jupyter-` 开头的 `systemd` 单元，其 CPU 和内存使用量被严格限制在您所设置的值内。

## 5. 阶段四：配置自动化系统清理 (Culling)

此阶段的目标是实现“沙箱若长期空闲会被自动清除”和“自动清理用户文件”的闭环。

 **架构洞察** ：这是一个三阶段的清理链条，它构成了临时架构的后半部分，用于完成临时用户的生命周期管理：

1. **`services.cull.timeout`** : `Idle Culler` 服务（默认启用）识别到*服务器* (Server) 实例长时间空闲 ^7^，并触发关闭。
2. **`SystemdSpawner`** : (在阶段二 B 部分配置) 检测到服务器被关闭，`systemd` 会自动停用 *动态系统用户* ，并销毁其位于 `/var/lib/{USERNAME}` 的主目录（及其所有文件）^5^。
3. **`services.cull.users = True`** : `Idle Culler` 服务在清理完服务器后，接着从 JupyterHub 的*数据库*中删除该*逻辑用户* (`tmp-...` 用户) 的条目 ^7^。

 *结果* ：如果缺少第 1 步，服务器将永远运行。如果缺少第 3 步，JupyterHub 数据库将充满了已失效的 `tmp-...` "幽灵"用户记录。这三步缺一不可。

### 5.1 步骤 1：配置服务器空闲超时

设置一个合理的空闲超时时间，单位为秒。TLJH 默认值为 3600 (1 小时) ^7^。这里我们设置为 7200 (2 小时)。

**Bash**

```
# 设置空闲 2 小时 (7200 秒) 后关闭服务器
sudo tljh-config set services.cull.timeout 7200
```

### 5.2 步骤 2：(可选) 调整检查周期

`services.cull.every` 定义了清理服务多久检查一次。默认值为 600 (10 分钟) ^7^，通常已足够。

**Bash**

```
# (可选) 设置每 5 分钟 (300 秒) 检查一次
sudo tljh-config set services.cull.every 300
```

### 5.3 步骤 3：(关键) 启用用户清理

这是完成“自动清理”闭环的 **关键步骤** 。默认情况下，TLJH *不会* 删除用户条目 (`False`) ^7^。对于 `TmpAuthenticator` 这种临时用例，必须将其设置为 `True` ^7^。

**Bash**

```
# 在服务器被清理后，同时从数据库中删除该用户
sudo tljh-config set services.cull.users True
```

### 5.4 步骤 4：重载配置

`culler` 是一个服务，其配置更改需要重载 ^7^：

**Bash**

```
sudo tljh-config reload
```

## 6. 阶段五：Gitea 集成：内容交付与访问控制

此阶段的目标是构造可分享的 Gitea 链接，并解决核心难题：如何让匿名的临时用户访问您的 *私有* Gitea 仓库。

### 6.1 A 部分：生成 nbgitpuller 共享链接

`nbgitpuller` 通过一个精心构造的 URL 来工作。它会拦截该 URL，执行 `git pull`，然后将用户重定向到指定的文件 ^6^。

与 `TmpAuthenticator` 结合使用时，完整的 URL 结构如下：

`/hub/login?next=/git-pull?repo=&branch=&urlpath=[File_Path]`

 **工作流解释** ：

1. 用户访问此 URL。
2. 浏览器首先请求 `/hub/login`。
3. `TmpAuthenticator` (阶段二 A) 拦截此请求，立即创建 `tmp-` 用户并认证会话。
4. `TmpAuthenticator` 将用户重定向到 URL 中的 `next` 参数，即 `/git-pull?...`。
5. `nbgitpuller` (阶段一) 拦截 `/git-pull` 请求，解析剩余参数，并执行 `git clone` 或 `git pull`。
6. 完成后，`nbgitpuller` 将用户重定向到 `urlpath` 指定的 Notebook。

**表 1：nbgitpuller URL 参数详解 (Gitea 案例)**

| **参数**        | **示例值**                                       | **描述 (参考: [24, 25, 26])**                                                                                                                                                              |
| --------------------- | ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **``**          | `https://jupyter.your-domain.com`                    | 您的 TLJH 服务器的公开访问地址。                                                                                                                                                                 |
| **`repo`**    | `https://gitea.your-domain.com/ss-cases/case-01.git` | 必须是 Gitea 仓库的**完整 HTTPS 克隆地址** 。                                                                                                                                              |
| **`branch`**  | `main`                                               | 要拉取的 Git 分支名称 (例如 `main`或 `master`) [24]。                                                                                                                                        |
| **`urlpath`** | `lab/tree/case-01/Analysis.ipynb`                    | **(极易出错)**要自动打开的文件路径，相对于仓库根目录。-`lab/tree/`前缀是打开 JupyterLab 界面所必需的 [24, 26]。- 路径中**必须**包含仓库本身的目录名 (本例中为 `case-01/`) [24]。 |

 **公开仓库链接示例** ：

如果您的 Gitea 仓库 (`case-01`) 是公开的 (Public)，则最终分享链接如下：

`https://jupyter.your-domain.com/hub/login?next=/git-pull?repo=https://gitea.your-domain.com/ss-cases/case-01.git&branch=main&urlpath=lab/tree/case-01/Analysis.ipynb`

### 6.2 B 部分：高级实施：访问私有 Gitea 仓库

 **问题分析** ：如果您的 Gitea 仓库是*私有*的，上述链接将失败。`tmp-` 匿名用户没有 Gitea 凭证，`nbgitpuller` 执行 `git clone` 时会收到“身份验证失败”的错误 ^27^。

架构设计 (服务器端凭证注入)：

我们不能将凭证（Token）暴露给学生。解决方案是在服务器端，在 git clone 命令执行之前，自动为该临时沙箱注入 Gitea 凭证。

1. JupyterHub 提供了一个 `c.Spawner.pre_spawn_hook` ^18^，它允许在服务器启动前执行一个 Python 函数。
2. *但是* ，由于我们使用了 `dynamic_users = True`，用户主目录 (`/var/lib/...`) 在 `pre_spawn_hook` 执行时可能尚不存在，或存在竞态条件 ^32^。
3. 更稳健的方案是：使用 `c.Spawner.cmd` 替换掉默认的 `jupyterhub-singleuser` 启动命令，转而指向一个我们自定义的*启动包装脚本* (wrapper script) ^18^。
4. 该脚本将在新用户的（临时的）环境中执行。它的任务是：
   a.  读取一个存放在安全位置（仅 root 可读）的 Gitea 访问令牌 (Access Token)。
   b.  在用户的临时主目录中创建临时的 git 配置文件 (.gitconfig 和 .git-credentials) 33。
   c.  最后，使用 exec 命令启动原始的 jupyterhub-singleuser 进程 32。

#### 6.2.1 步骤 1：创建 Gitea 访问令牌 (Access Token)

1. 登录您的 Gitea。
2. 创建一个专用的“机器用户”（例如 `jupyter_bot`）。
3. 授予此用户对所有社会科学案例仓库的*只读 (Read)* 权限。
4. 为此“机器用户”生成一个访问令牌 (Access Token)。 **复制并安全地保存此令牌字符串** 。

#### 6.2.2 步骤 2：在 TLJH 服务器上安全存储令牌

通过 SSH 登录服务器，将令牌存储在一个只有 `root` 能读取的文件中：

**Bash**

```
# 创建文件并粘贴令牌字符串
sudo nano /opt/tljh/config/gitea_token.txt

# 锁定文件权限
sudo chmod 600 /opt/tljh/config/gitea_token.txt
```

#### 6.2.3 步骤 3：创建 Spawner 启动包装脚本

1. 创建脚本文件：
   **Bash**

   ```
   sudo nano /opt/tljh/config/spawn-wrapper.sh
   ```
2. 将以下脚本内容粘贴到文件中。**注意：请将 `gitea.your-domain.com` 替换为您 Gitea 实例的实际主机名。**
   **Bash**

   ```
   #!/bin/bash

   # 这是一个 c.Spawner.cmd 包装脚本。
   # 它会接收所有原应传递给 jupyterhub-singleuser 的参数。

   # SystemdSpawner (在 dynamic_users=True 时) 会设置 HOME 环境变量
   # 指向 /var/lib/{USERNAME} 
   USER_HOME=$HOME

   if; then
       echo "错误：HOME 环境变量未设置。" >&2
       exit 1
   fi

   # --- Gitea 凭证注入 ---
   #!! 修改为您自己的 Gitea 主机名!!
   GITEA_HOST="gitea.your-domain.com"
   GITEA_TOKEN=$(cat /opt/tljh/config/gitea_token.txt)

   GIT_CONFIG_DIR="$USER_HOME/.config/git"
   GIT_CRED_FILE="$USER_HOME/.git-credentials"

   mkdir -p "$GIT_CONFIG_DIR"

   # 1. 设置.gitconfig，告诉 git 使用 'store' 助手
   # 
   echo -e "[credential]\n    helper = store" > "$USER_HOME/.gitconfig"

   # 2. 写入 Gitea 凭证
   # 格式为: https://[user]:[token]@[host]
   # 对于 Gitea/GitHub Token，用户名可以是 oauth2
   echo "https://oauth2:${GITEA_TOKEN}@${GITEA_HOST}" > "$GIT_CRED_FILE"

   # 3. 锁定凭证文件权限
   chmod 600 "$GIT_CRED_FILE"

   # (systemd 已经确保了 $USER_HOME 的所有权，无需 chown)

   # --- 启动原始的 Jupyter 进程 ---
   # 使用 exec 交出进程控制权 
   exec jupyterhub-singleuser "$@"
   ```
3. 赋予此脚本执行权限：
   **Bash**

   ```
   sudo chmod +x /opt/tljh/config/spawn-wrapper.sh
   ```

#### 6.2.4 步骤 4：配置 Spawner 使用包装脚本

打开我们在阶段二 B 部分创建的自定义配置文件：

**Bash**

```
sudo nano /opt/tljh/config/jupyterhub_config.d/99-ephemeral-users.py
```

在文件末尾添加 `c.Spawner.cmd` 配置，使其指向我们的新脚本：

**Python**

```
# /opt/tljh/config/jupyterhub_config.d/99-ephemeral-users.py

# --- (阶段二 B 已配置) ---
# 启用动态用户
c.SystemdSpawner.dynamic_users = True

# --- (阶段五 B 新增配置) ---
# 覆盖默认的 spawner 启动命令
# 
# 指向我们的包装脚本，该脚本会先注入 Gitea 凭证，然后再启动服务器。
c.Spawner.cmd = ['/opt/tljh/config/spawn-wrapper.sh']
```

#### 6.2.5 步骤 5：重载配置

这是一个对 Spawner 的根本性改动，必须重载服务：

**Bash**

```
sudo tljh-config reload
```

 **验证** ：现在，使用一个指向*私有* Gitea 仓库的 `nbgitpuller` 链接（格式同 6.1 A 部分）。服务器应该能正常启动，`nbgitpuller` 进度条出现，并成功克隆私有仓库，最后自动打开指定的 Notebook。

## 7. 最终工作流验证与配置总结

### 7.1 端到端工作流（学生体验）

1. **点击** ：您（教师）将一个 `nbgitpuller` 链接（如阶段五 A 所示）发送给学生。
2. **认证** ：学生点击链接。浏览器请求 `/hub/login`。`TmpAuthenticator` 拦截请求，在 Hub 数据库中创建*逻辑用户* `tmp-xyz`，并立即将会话重定向到 `next` 参数（即 `/git-pull?...`）。
3. **分配沙箱** ：JupyterHub 指示 `SystemdSpawner` 为 `tmp-xyz` 启动服务器。
4. **创建沙箱** ：`SystemdSpawner` (因 `dynamic_users = True`) 指示 `systemd` 创建一个 *物理临时用户* ，其主目录在 `/var/lib/tmp-xyz`。阶段三中配置的 CPU/内存限制（Cgroups）被应用 ^5^。
5. **注入凭证** ：Spawner *不* 直接运行 `jupyterhub-singleuser`，而是执行 `c.Spawner.cmd` 指定的 `/opt/tljh/config/spawn-wrapper.sh` ^18^。
6. **配置 Git** ：`spawn-wrapper.sh` 脚本在 `/var/lib/tmp-xyz` 目录中创建了 `.gitconfig` 和 `.git-credentials` 文件，其中包含了 Gitea 的只读令牌 ^33^。
7. **启动服务** ：`spawn-wrapper.sh` 脚本最后 `exec jupyterhub-singleuser`，Jupyter 服务器进程启动。
8. **拉取内容** ：Jupyter 服务器启动时加载了 `nbgitpuller` 扩展。该扩展处理 `/git-pull` 请求，并执行 `git clone...` 命令。
9. **Git 认证** ：`git` 命令读取在步骤 6 中注入的 `.gitconfig` 和 `.git-credentials`，成功通过 Gitea 的身份验证，私有仓库被成功克隆。
10. **打开文件** ：`nbgitpuller` 将学生重定向到 `urlpath` 指定的 Notebook（例如 `.../lab/tree/case-01/Analysis.ipynb`）。
11. **工作** ：学生在受限的沙箱环境中进行数据分析。
12. **空闲** ：学生完成工作并关闭浏览器标签页。
13. **清理服务器** ：2 小时后（由 `services.cull.timeout` 定义 ^7^），`Idle Culler` 服务检测到服务器空闲，并将其关闭。
14. **销毁数据** ：`SystemdSpawner` 检测到服务器关闭。`systemd` 随之停用该 *动态系统用户* ，并自动、递归地删除其主目录 `/var/lib/tmp-xyz` 及其所有内容（包括代码和学生生成的文件）^5^。
15. **清理用户** ：`Idle Culler` 服务（因 `services.cull.users = True` ^7^）接着从 JupyterHub 数据库中删除*逻辑用户* `tmp-xyz` 的条目。
16. **完成** ：系统恢复到初始状态，没有留下任何文件或用户数据。

### 7.2 配置总结清单

下表汇总了本指南中执行的所有关键配置，可用于故障排查：

**表 2：架构配置项总结**

| **组件**              | **配置方法** | **路径 / 命令**                                          | **关键配置值**                                      | **目的**                              |
| --------------------------- | ------------------ | -------------------------------------------------------------- | --------------------------------------------------------- | ------------------------------------------- |
| **nbgitpuller**       | 用户端 Pip         | `/opt/tljh/user/bin/pip`                                     | `install nbgitpuller`                                   | 处理 `/git-pull`链接 [35, 36]。           |
| **认证 (安装)**       | Hub 端 Pip         | `/opt/tljh/hub/bin/pip`                                      | `install jupyterhub-tmpauthenticator`                   | 安装免登录认证器^2^。                       |
| **认证 (启用)**       | TLJH Config        | `sudo tljh-config`                                           | `set auth.type tmpauthenticator.TmpAuthenticator`       | 启用免登录访问 [12]。                       |
| **Spawner (临时性)**  | Ecapse Hatch       | `/opt/tljh/config/jupyterhub_config.d/99-ephemeral-users.py` | `c.SystemdSpawner.dynamic_users = True`                 | 创建临时的、用后即焚的系统用户和主目录^3^。 |
| **资源限制**          | TLJH Config        | `sudo tljh-config`                                           | `set limits.memory 4G` `set limits.cpu 2`             | 限制每个沙箱的 CPU/内存^13^。               |
| **清理 (服务器)**     | TLJH Config        | `sudo tljh-config`                                           | `set services.cull.timeout 7200`                        | 关闭空闲 2 小时的服务器^7^。                |
| **清理 (用户)**       | TLJH Config        | `sudo tljh-config`                                           | `set services.cull.users True`                          | 在服务器关闭后，从数据库中删除用户记录^7^。 |
| **Gitea 凭证 (存储)** | 安全文件           | `/opt/tljh/config/gitea_token.txt`                           | `(您的 Gitea 令牌)`                                     | 根用户可读的令牌存储。                      |
| **Gitea 凭证 (脚本)** | 自定义脚本         | `/opt/tljh/config/spawn-wrapper.sh`                          | `(Bash 脚本内容)`                                       | 在沙箱启动时注入 Git 凭证。                 |
| **Gitea 凭证 (注入)** | Ecapse Hatch       | `/opt/tljh/config/jupyterhub_config.d/99-ephemeral-users.py` | `c.Spawner.cmd = ['/opt/tljh/config/spawn-wrapper.sh']` | 替换 Spawner 命令以执行凭证注入脚本^18^。   |

## 8. 结论

本指南详细描述的架构建立了一个功能强大、全自动化的临时沙箱环境，精确满足了用户的所有六项要求。该系统的核心复杂性在于为匿名用户提供对私有 Gitea 仓库的安全访问。

 **重要建议** ：如果您的社会科学案例仓库不包含敏感数据，强烈建议将其在 Gitea 中的可见性设置为“公开” (Public)。如果仓库是公开的，`nbgitpuller` 无需身份验证即可克隆。这将允许您跳过本指南中第 6.2 B 部分的*所有*步骤（即令牌、`spawn-wrapper.sh` 脚本和 `c.Spawner.cmd` 配置），从而极大地简化系统的复杂性和长期维护成本。
