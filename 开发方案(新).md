# 在线代码案例学习平台：详细开发方案 (内网简化版)

**重要提示：** 此方案已根据在**受信任的内部网络**中部署的需求进行了简化，省略了所有面向公网的安全措施（如HTTPS加密、复杂的用户认证等）。请确保仅在安全、可控的网络环境中使用。

---

#### 1. 项目概述与目标

**项目名称：** 交互式数据集案例学习平台

**核心目标：** 基于现有的数据集分享平台 (`apps/web-frontend`) 和PostgreSQL数据库，构建一个全新的在线学习环境。该环境允许学生和研究者通过Web浏览器，一键启动与特定论文案例匹配的交互式代码环境（JupyterLab），直接运行和修改复现代码，并通过平台API (`apps/api-backend`) 实时调用所需数据集，实现从理论到实践的无缝学习闭环。

**最终用户体验：**

1.  用户在数据集分享平台上浏览一篇论文的使用案例。
2.  点击【在线运行】按钮。
3.  系统自动跳转至一个已加载好该论文复现代码的JupyterLab界面。
4.  用户在JupyterLab中执行代码单元格。
5.  代码通过平台API安全地获取数据集。
6.  用户实时看到运行结果、图表和分析，并可自由探索和修改代码。

#### 2. 核心技术栈与架构

*   **服务器操作系统：** Windows 10/11 或 Windows Server
*   **核心依赖：** WSL2 (Windows Subsystem for Linux)
*   **容器化技术：** Docker Desktop for Windows
*   **核心应用：** JupyterHub
*   **环境生成器 (Spawner)：** DockerSpawner
*   **代码分发工具：** nbgitpuller
*   **代码托管：** 自建 GitLab
*   **反向代理与网关：** Nginx (可选，用于简化访问路径)
*   **数据库：** PostgreSQL (沿用现有)
*   **前端整合：** 修改 `apps/web-frontend`
*   **后端API：** 沿用 `apps/api-backend`

**架构图：**

```mermaid
graph TD
    A[用户浏览器] --> B{数据集分享平台 (apps/web-frontend)};
    B -- 点击"在线运行"按钮 (链接至 http://<服务器IP>) --> D[JupyterHub 服务];
    D -- 自动认证 --> D;
    D -- 使用 DockerSpawner --> E{创建用户专属Docker容器};
    E -- 启动时触发 --> F[nbgitpuller];
    F -- 拉取代码 --> G[自建 GitLab 仓库];
    E -- 运行JupyterLab --> A;
    
    subgraph 用户专属容器
        H[JupyterLab 进程]
        I[复现代码 .ipynb]
        J[Python/R 环境]
    end

    E --> H;
    F -- 填充 --> I;
    I -- 代码执行 --> J;
    J -- 通过API请求 --> K[数据平台API (apps/api-backend)];
    K -- 访问 --> L[PostgreSQL数据库];
    K -- 返回数据 --> J;
```

#### 3. 实施阶段与任务分解

**第一阶段：基础设施与环境准备 (Windows环境)**

1.  **准备Windows服务器/PC：**
    *   确保服务器有一个**固定的内网IP地址** (例如 `192.168.1.100`)。
    *   硬件建议：至少 4 核 CPU, 16GB RAM, 100GB SSD 存储。
2.  **安装和配置WSL2：**
    *   打开PowerShell (管理员权限)，运行 `wsl --install`。这会自动安装Ubuntu发行版。
    *   确认WSL版本为2，运行 `wsl -l -v`。
3.  **安装Docker Desktop for Windows：**
    *   从Docker官网下载并安装。
    *   在Docker Desktop的设置中，确保 "Use the WSL 2 based engine" 选项已开启。
4.  **(可选) 安装Nginx：** 如果您希望通过 `http://<服务器IP>` 而不是 `http://<服务器IP>:8000` 访问，可以安装Nginx作为反向代理。对于内网环境，直接使用端口访问也是完全可以的。
5.  **配置防火墙：**
    *   确保Windows防火墙允许内网其他计算机访问JupyterHub服务所需的端口（默认为 `8000`，如果使用Nginx则是 `80`）。

**第二阶段：JupyterHub 核心服务部署**

1.  **创建项目目录结构 (在WSL2环境中)：**
    *   **重要建议：** 将项目文件放在WSL2的文件系统内，而不是Windows的C:盘，以获得最佳性能和兼容性。
    *   打开WSL2终端 (在PowerShell中输入 `wsl`)，然后创建目录：
    ```bash
    # 在WSL2的 home 目录下
    cd ~
    git clone your-monorepo-url
    cd UCASS_DataShare/apps/
    mkdir jupyter-service
    cd jupyter-service
    mkdir -p user_environment
    touch docker-compose.yml jupyterhub_config.py user_environment/Dockerfile
    ```
2.  **构建基础用户镜像 (`apps/jupyter-service/user_environment/Dockerfile`)：**
    *   基于官方Jupyter镜像 (`jupyter/scipy-notebook` 或 `jupyter/tensorflow-notebook`)。
    *   安装 `nbgitpuller`。
    *   安装项目通用的Python库 (Pandas, Matplotlib, Requests等)。
3.  **编写JupyterHub配置 (`apps/jupyter-service/jupyterhub_config.py`)：**
    *   **核心简化：** 设置认证方式为 `DummyAuthenticator`，允许任何人输入任意用户名直接登录，无需密码。
4.  **编写 `apps/jupyter-service/docker-compose.yml`：**
    *   定义 `jupyterhub` 服务，挂载配置文件。
    *   定义 `nginx` 服务作为反向代理（也可在服务器上独立配置Nginx）。
5.  **启动与测试 (在WSL2终端中)：**
    *   进入 `~/UCASS_DataShare/apps/jupyter-service` 目录，运行 `docker-compose up -d`。
    *   在浏览器中访问 `http://<服务器IP>:8000`，应能看到JupyterHub的登录页。输入任意用户名，点击登录即可进入。

**第三阶段：案例内容与数据API整合**

1.  **创建Git案例仓库：**
    *   在您的**自建GitLab服务器**上创建一个新的**公共**项目（或私有，但需额外配置访问凭证）。
    *   为一篇论文创建一个文件夹，里面包含 `notebook.ipynb` 文件。
2.  **编写Notebook内容 (`notebook.ipynb`)：**
    *   **关键步骤：** 在Notebook的起始部分，编写调用您 `api-backend` 数据接口的代码。
    *   **安全实践：** 使用环境变量 (`os.environ.get('API_KEY')`) 来获取API密钥，而不是硬编码。密钥将在下一步中配置。
3.  **更新 `jupyterhub_config.py` 以注入环境变量：**
    *   配置 `DockerSpawner`，使其在启动每个用户容器时，都自动注入访问 `api-backend` 所需的API密钥。
    *   例如：`c.DockerSpawner.environment = {'API_KEY': 'your-secret-key-for-api-backend'}`。
4.  **配置API后端 (`apps/api-backend`)**
    *   确保为JupyterHub实例配置了CORS策略，允许来自 `lab.yourdomain.com` 的请求。

**第四阶段：前端平台与工作流打通**

1.  **生成 `nbgitpuller` 链接：**
    *   格式: `http://[服务器IP]:8000/hub/user-redirect/git-pull?repo=[自建GitLab仓库URL]&urlpath=lab/tree/[仓库名]/[Notebook路径]`
    *   **示例:** `http://192.168.1.100:8000/hub/user-redirect/git-pull?repo=http%3A%2F%2Fgitlab.internal%2Fgroup%2Fmy-cases.git&urlpath=lab%2Ftree%2Fmy-cases%2Fpaper1%2Fnotebook.ipynb`
2.  **改造前端平台 (`apps/web-frontend`)：**
    *   在展示数据集或论文案例的页面（例如 `app/datasets/[id]/page.tsx`）中，找到或创建一个"在线运行"按钮。
    *   将其 `href` 属性设置为上面为该案例生成的 `nbgitpuller` 链接。
3.  **端到端测试：**
    *   模拟完整用户流程，确保从前端点击按钮到在JupyterLab中成功加载代码并获取数据的所有环节都通畅无误。

**第五阶段：优化与上线**

1.  **配置资源限制：**
    *   **(强烈建议)** 在 `jupyterhub_config.py` 中为每个用户容器设置CPU和内存使用上限，防止资源滥用，这在任何环境下都很重要。
    *   `c.DockerSpawner.mem_limit = '2G'`
    *   `c.DockerSpawner.cpu_limit = 2`
2.  **数据持久化 (可选)：**
    *   如果希望用户能保存自己的代码修改，可以配置 `DockerSpawner` 将用户的主目录挂载到服务器的某个位置。
3.  **监控与备份 (可选)：**
    *   在内部环境中，可以根据需要监控服务器资源。定期备份 `apps/jupyter-service` 中的配置文件是个好习惯。

#### 4. 关键任务详细说明

*   **`jupyterhub_config.py` 核心配置示例 (简化版):**
    ```python
    import os
    
    # --- 简化认证 ---
    # 允许任何用户输入任意用户名登录，无需密码
    c.JupyterHub.authenticator_class = 'dummy'

    # --- Spawner 配置 ---
    c.JupyterHub.spawner_class = 'dockerspawner.DockerSpawner'
    c.DockerSpawner.image = 'jupyter-service-user-env:latest'
    c.DockerSpawner.network_name = 'jupyter-service_default' 
    c.DockerSpawner.remove = True 

    # --- 环境变量注入 (依然推荐) ---
    c.Spawner.environment = {
        'API_KEY': os.environ.get('DATA_PLATFORM_API_KEY', '')
    }
    ```

#### 5. 资源与成本预估

*   **人力资源：**
    *   1位 **后端/DevOps工程师** (主力)，负责服务器、Docker、JupyterHub的部署和维护。
    *   1位 **前端工程师** (兼职)，负责将nbgitpuller链接整合到 `web-frontend`。
    *   1位 **内容创建者/数据科学家** (兼职)，负责编写和整理复现案例的Notebook。
*   **硬件成本：**
    *   云服务器租用费用（根据配置和使用时长决定）。
    *   数据存储和网络流量费用。
*   **时间线预估：**
    *   理想情况下，一个经验丰富的工程师可以在 **3-4周内** 完成一个功能完善的MVP版本。

#### 6. 风险与应对策略

*   **风险：** 计算资源被恶意或低效代码耗尽。
    *   **应对：** **必须为每个容器设置严格的CPU和内存限制。** 这是最重要的内部风险防范措施。
*   **风险：** 容器网络配置错误导致无法访问 `api-backend` 或 `GitLab`。
    *   **应对：** 确保Docker容器的网络配置正确，能够解析和访问内网中的其他服务。
*   **风险 (Windows特定)：** 在Windows文件系统和WSL2文件系统之间进行文件操作可能导致性能下降或路径问题。
    *   **应对：** **强烈建议将所有项目代码和配置文件都存放在WSL2的文件系统内部。**

---

这份方案提供了一个清晰、可行的实施路径。只要您的团队按照这些阶段稳步推进，就一定能成功构建出这个富有价值的在线学习平台。祝您项目顺利！
